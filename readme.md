Адаптация алгоритма Дейкстры для расчёта кратчайших путей в IP-сетях.
-
Изначально алгоритм предназначен для **направленных графов** с положительными весами рёбер. Направленный означает, что пройти по нему можно **только в одном направлении**. Но в сетях IPv4 это требование кажется невыполнимым : любой интерфейс или порт является дуплексным, т.е. может как принимать, так и отправлять данные. Иными словами любое ребро в реальной сети передачи данных ненаправленно. Абстрагирование позволяет заменить его на два направленных ребра между теми же двумя узлами, приэтом требование будет соблюдено. В данной реализации направленному ребру было дано название "линк смежности" **(adjacency link)**. Полная база данных графа, это массив из линков смежности, каждый из которых описан структурой :

    struct {
        u32i nodeID;
        u32i localIP;
        u32i mask;
        u32i cost;
        u32i neighIP;
        u32i neighID;
    };

Здесь и далее u32i это краткая запись для типа uint32_t и является полным аналогом адреса IPv4.

|переменная  | описание |
|--|--|
| nodeID | идентификатор узла в виде ip-адреса |
| localIP| ip-адрес на локальном интерфейсе этого узла
| mask   | маска интерфейса
| cost   | локальная стоимость интерфейса ( >=1 за исключением лупбеков)
| neighIP| ip-адрес на удалённом интерфейсе
| neighID| идентификатор удалённого узла в виде ip-адреса

Пара любых соседних узлов требует две записи типа adjLnk.

Например следующая простейшая топология :

![djk_ipv4 diagram01](diagram01.png)

описывается двумя линками смежности :  
  
|NodeID|localIP|mask|cost|neighIP|neighID|  
|--|--|--|--|--|--|--|  
|192.0.2.1|198.51.100.5|255.255.255.252|20000|198.51.100.6|203.0.113.4  
|203.0.113.4|198.51.100.6|255.255.255.252|10000|198.51.100.5|192.0.2.1  

Стоимость линка может отличаться с одной и другой стороны, это нормальная практика для сетей передачи данных.

Дизайн проекта
-
В основе лежат два класса :

 - **GraphIPv4** - сам граф
 - **DjkIPv4** - дерево, получаемое из графа

В первую очередь нужно пополнить объект класса GraphIPv4 данными, затем передать его в конструктор объекта DjkIPv4 для расчёта дерева.

Для пополнения графа используются методы :

    void addLink(nodeIDv4_t nodeID, linkAdjv4_t link); // добавляет один линк смежности
    void addLinks(vector <linkAdjStr_t> *table);  // добавляет все линки смежности из переданной таблицы
    void addLinksFromFile(const string &fn); // загружает все линки смежности из двоичного файла

В случае простых топологий можно вносить каждый линк через отдельные вызовы `::addLink()`, либо построить вектор и передать его в `::addLinks()`.

Более интересен метод пополнения из двоичного файла `::addLinksFromFile()`, правда для этого потребуется доступ к реальному маршрутизатору **Cisco ASR**, работающему под управлением операционной системы **IOS XR**. Нужно собрать вывод команды "show ospf database router" в текстовый файл и передать на обработку утилите xroconv (XR OSPF Converter), которая выложена здесь же в архиве xroconv.zip. Утилита ограничена записями типа LSA Type 0, других она не понимает и будет пропускать. Сгенерированный файл представляет собой бинарник из записей типа adjLnk, следующих один за другим без каких-либо дополнительных разделителей.

Компиляция полного проекта с файлом main.cpp даст рабочую утилиту, в которую можно будет передать полученный двоичный файл. На экран будет выведена результирующая таблица маршрутизации (Router Information Base).
